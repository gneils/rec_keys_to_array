|| Generated by DP - don't edit anything outside |{...|}

|{ Header
| File name: NAVIGATE.MAIN
| Path:      DCC.sr4
| Creator:   David Merle, Greg Neils
| Created:   04/12/2007
| Retired:
| Called by: 12 databases use this
| Calls:
| Reason:    A new and improved (hopefully) version of the DIALOG.MAINMENU
| Output:
| Modified:  1. 09/17/2007 David Merle Removed error "Sorry, refreshing display."
|            2. 09/17/2007 David Merle Created new variable for checking CAT VARS: CAT$V
|            3. 09/21/2007 David Merle The form name might not have DOCUMENT text after it, so checking
|            for a ' ' could be problematic.
|            4. 09/21/2007 David Merle New module: Check for NAVIGATE.LOADFORM
|            5. 09/23/2007 David Merle Modified module: NAVIGATE.GOTOSCREEN. The idea is if NAVIGATE.GOTOSCREEN returns PROCEED = NO
|            then you don't want to do any of the regular GOTO_SCREEN stuff.
|            6. 05/01/2009 Added exit out code
call DCCPROCF.SYSTEM.ALLRECS
GLOBAL RTB = $; execute subprocedure WRITE_TO_BUFFER$
PROGRAM
IFTHEN ( VTYPE(0,KEYNAME(0,1)) EQ 1)
. T = GLOBALN('CASE_TYPE' , 1) | STRING
ELSE
. T = GLOBALN('CASE_TYPE' , 0) | NUMERIC
ENDIF
END PROGRAM
retrieval update noautocase crwarn dynamic
|}

integer*2 m_id, m_arg1, m_arg2

integer*1 IDSTATIC; preset IDSTATIC (-1)
integer*1 IDCLOSE ; preset IDCLOSE  ( 0)
integer*1 FIND_SUB                        ; preset FIND_SUB                         (1 )
integer*1 FIND_SUBL                       ; preset FIND_SUBL                        (2 )
integer*1 FIND_SUBB                       ; preset FIND_SUBB                        (3 )
integer*1 SUBJECTL                        ; preset SUBJECTL                         (4 )
integer*1 SUBJECTS                        ; preset SUBJECTS                         (5 )
integer*1 FORML                           ; preset FORML                            (6 )
integer*1 FORMS                           ; preset FORMS                            (7 )
integer*1 KEY1L                           ; preset KEY1L                            (8 )
integer*1 KEY1                            ; preset KEY1                             (9 )
integer*1 KEY2L                           ; preset KEY2L                            (10 )
integer*1 KEY2                            ; preset KEY2                             (11 )
integer*1 KEY3L                           ; preset KEY3L                            (12 )
integer*1 KEY3                            ; preset KEY3                             (13 )
integer*1 KEY4L                           ; preset KEY4L                            (14 )
integer*1 KEY4                            ; preset KEY4                             (15 )
integer*1 REC_CNTL                        ; preset REC_CNTL                         (16 )
integer*1 ADDNEWF                         ; preset ADDNEWF                          (17 )
integer*1 TEMPEXIT                        ; preset TEMPEXIT                         (18 )
integer*1 STATS_B                         ; preset STATS_B                          (19 )
integer*1 SEARCH_B                        ; preset SEARCH_B                         (20 )
integer*1 BUTTON1                         ; preset BUTTON1                          (21 )
integer*1 BUTTON2                         ; preset BUTTON2                          (22 )
integer*1 BIG_SUBJ                        ; preset BIG_SUBJ                         (23 )
integer*1 SUBJINFO                        ; preset SUBJINFO                         (24 )
integer*1 ID_00001                        ; preset ID_00001                         (25 )
integer*1 ID_00003                        ; preset ID_00003                         (26 )
integer*1 PTITLE                          ; preset PTITLE                           (27 )
integer*1 FORMCNT                         ; preset FORMCNT                          (28 )
integer*1 TIME_OUT_LABEL                  ; preset TIME_OUT_LABEL                   (29 )
integer*1 HIPAA1                          ; preset HIPAA1                           (30 )
integer*1 HIPAA3                          ; preset HIPAA3                           (31 )
integer*1 ID_00004                        ; preset ID_00004                         (32 )

|{ Prologue
|}

dialog "Main Navigation"

|{ Controls
postype 1
edit     FIND_SUB                        ,  20,       10, 110, 0, 0
label    FIND_SUBL                       ,  35,       10, 110, "Find Subject"
button   FIND_SUBB                       , 268,      288,  70, 1, ""
label    SUBJECTL                        ,  52,       10, 110, ""
list     SUBJECTS                        ,  62, 184,  10, 110, 0
label    FORML                           ,  52,      130,  28, "Forms"
list     FORMS                           ,  62, 184, 130, 230, 0
label    KEY1L                           ,  10,      370,  80, ""
list     KEY1                            ,  20,  70, 370, 110, 0
label    KEY2L                           ,  93,      370, 110, ""
list     KEY2                            , 103,  70, 370, 110, 0
label    KEY3L                           , 176,      370, 110, ""
list     KEY3                            , 186,  70, 370, 110, 0
label    KEY4L                           , 259,      370, 110, ""
list     KEY4                            , 269,  65, 370, 110, 0
label    REC_CNTL                        , 360,      469,  18, "1234"
button   ADDNEWF                         ,  48,      258, 100, 0, "Changes to Form Name"
button   TEMPEXIT                        ,   0,      454,  35, 0, "Exit"
button   STATS_B                         , 256,      210,  70, 0, "&List Stats"
button   SEARCH_B                        , 275,      210,  70, 0, "Search"
button   BUTTON1                         , 294,      210,  70, 0, ""
button   BUTTON2                         , 313,      210,  70, 0, ""
label    BIG_SUBJ                        ,  27,      136, 220, "Changes to CASEID"
text     SUBJINFO                        , 256,  68,  10, 190, 1
line     IDSTATIC                        ,   0, 370,   0, 490
line     ID_00001                        ,  20,  23, 130, 230
label    ID_00003                        , 360,      427,  40, "Version 5A"
label    PTITLE                          ,   6,       10, 230, ""
label    FORMCNT                         ,  52,      189,  64, "Changes"
label    TIME_OUT_LABEL                  ,   7,      258, 100, "Minutes until time out: 10"
label    HIPAA1                          , 336,       22, 326, "The information contained in this database is confidential. All database use is logged and monitored."
label    HIPAA3                          , 346,       22, 327, "Unauthorized or improper use of this system, or the information it contains, is prohibited."
line     ID_00004                        , 330,  32,  10, 353
|}

initial
|{ Attribs
|< REC_CNTL
. SET ITEM FONT REC_CNTL,0,0,0, 0,"#C0C0C0"
|>
|< ID_00003
. SET ITEM FONT ID_00003,0,0,0, 0,"#C0C0C0"
|>
|< HIPAA1
. SET ITEM FONT HIPAA1,0,0,0, 0,"#0000C0"
|>
|< HIPAA3
. SET ITEM FONT HIPAA3,0,0,0, 0,"#0000C0"
|>

|}
|{ Init
| Declare variables
| Case
. string  *   20   NPFONT      | Font type for lists
. string  *   20   P_FONT      | Font type for lables
. string  *  200   DBHOME      | To display a big picture of the DB name
. integer *    1   NO YES CANCEL   | No=0 Yes=1
. integer *    2   CASETYPE    | What variable type is the case id
. string  *   32   CASE_$V     | CASE_A(getpos(SUBJECTS))
. string  *   32   CASE_$N     | Variable name of case, varname(0, 1)
. integer *    1   VTYPE_#     | What variable type is it
. string  *   30 array CASE_A  (100)    | For displaying the cases in the SUBJECTS list
. string  *   30 array COMMON1 (100)    | For displaying the first common variable in the SUBJECTS list
. string  *   30 array COMMON2 (100)    | For displaying the second common variable in the SUBJECTS list
. integer *    4   ARRAYSZ# CASE#
. string  *   32   SHOW_$      | String while readin thru caselist file
. integer *    1   EXIT__#     | Returning value from DVPainter
. integer *    1   BOLD N_BOLD ITALIC N_ITALIC UNDERL N_UNDERL SMALL LARGE  |Fonts specifications
. integer *    1   OURKEY#     | Which KEY is it in our terminology (ie we ignoring the fact that CASEID is KEY#1)
. integer *    1   VIAKEY#     | helps construct the VIA for case processing
. integer *    1   KEY#T       | Generic Type of Key vtype(REC_#, keyname(REC_#, KEY#))
. integer *    1   KEY#1T KEY#2T KEY#3T KEY#4T KEY#5T KEY#6T KEY#7T KEY#8T | Key Specific Type of Key vtype(REC_#, keyname(REC_#, KEY#))
. integer *    1   KEY#C       | How many keys a record has nkeys(REC_#)
. integer *    2   KEYMIN      | The minimum range of the key, if there is one
. integer *    2   KEYMAX      | The maximum range of the key, if there is one
. string  *   32   KEY$ KEY$1 KEY$2 KEY$3 KEY$4 KEY$5 KEY$6 KEY$7 KEY$8 KEY$N KEY$V   |Keys
. string  *   32   TEMPKEY1 TEMPKEY2 TEMPKEY3 TEMPKEY4 |TEMP Key VALUES FOR WHEN SOMEONE ENTERS IN A NEW KEY
. integer *    1   D_ITEM_#    | Very Tricky.  This contains the number of the DIALOG ITEM you want to append.  ie which Key display
. integer *    1   KEY1_REF    | Does Key1 need to be Refreshed INITIALY
. integer *    1   KEY2_REF    | Does Key2 need to be Refreshed INITIALY
. integer *    1   KEY3_REF    | Does Key3 need to be Refreshed INITIALY
. integer *    1   KEY4_REF    | Does Key4 need to be Refreshed INITIALY
. integer *    1   KEY1_CLK    | Does Key1 need to be Refreshed AFTER CLICK
. integer *    1   KEY2_CLK    | Does Key2 need to be Refreshed AFTER CLICK
. integer *    1   KEY3_CLK    | Does Key3 need to be Refreshed AFTER CLICK
. integer *    1   KEY4_CLK    | Does Key4 need to be Refreshed AFTER CLICK
. integer *    2   LAB_CNT     | number of labels for key
. integer *    2   REC_#       | Record #
. string  *   32   REC_$       | Constructing SCRN# for DVPainter
. string  *   32   DVPMEM$N    | Full call to the DVPainter Screen
. integer *    2   VALID_#     | Cycle thru items with value lables, VALID_# etc.
. integer *    2   POS         | abs(srst(KEY$V, ' '))  I dont quite get this one yet
. integer *    2   POS0        | Item user selected
. integer *    1   SPACEPOS    | the location of a space in SUBJECTS between the case ID and some other text i.e. name.
. integer *    1   MEM_O
. integer *    1   MEM_T
. integer *    1   PROCEED
. string  *   80   VIA_$       | Passing Keys with VIA to subroutines.
. integer *    1   CLCK_#      | (-1:Form) (0 Case) (1 Key1) (2 Key2) (3 Key3) (4 Key4)
. date DATE#V ('MMiDDiYYYY')   |Getting the right format for a Date Key
. time TIME#V ('HHiMMiSS')     |Getting the right format for a Time Key
. integer *    2   REC_#C      | How many records belong to that CASE and Record type
. string  *   32   MAYBENEW    | This may be a new CASEID new.  Check it first then pass to CASE_$V
. string  *   32   BUTTON1$
. string  *   32   BUTTON2$
|
. string  *   60   SCR$N         | Passed to Generic Screens.  It is the Recname.  Not sure why.
. string  *   32   SCRMEM$N      | String that calls Generic screens
. string  *   32   NEW_$         | New CaseID has been selected
. integer *    1   RESVAR        | Do you want to procede?  Yes NO or Cancel
| List of Forms information
. string  *   40   DOC$          | Something to do with the display length of a record type name
. integer *    1   FOUNDID       | Search for CASEID found something or not
. integer *    2   ANYNUM        | DELETE THIS VARIABLE OR RENAME IT.  used to test validation
. string  *   45   RECNM$        | Record name padded to the correct length
| buffer
. string  *   32   BUFF$N        | Buffer Name
. string  *  180   BUFF$         | Text to add to buffer
. integer *    1   LINE#         | Current line number to write in buffer
| new key screen
. integer *    1   PASSCHCK      | Are the new keys OK and did the user goto the form?
| end buffer
. integer *    1   GOODCAT       |Is it a valid categorical value?
. string  *   15   TYPEDATE      | What is the DATE format?
. string  *   15   TYPETIME      | What is the TIME format?
. integer *    1   FIND_KEY      | If the value of TEMPKEY was found in the list of Keys.  It is to check that a new form was really created.
. integer *    1   REPNT$        | When keys have to be completely repainted REPNT$ = 1
. integer *    1   NOMORE$       | Do No More = 1   continue = 0
. integer *    1   CLICK         | Used to send a message to local members whether a button was clicked or not.
. integer *    1   HMFIC         | Used for texting.  Added for exit out
. integer *    2   LOGOUTMINUTE  | Minutes until Time Out
. integer *    1   SEENMESS      | Has the user seen the message
. string  *  200   MESSPATH      | Message file path
|
|
|
| additional variables
REAL    *   8  CASE_#V
integer *   2  db_row                | database row
integer *   1  key_count             | how many keys are there
string  *  32  array db_rec_keys   ( 100, 8 ) |row, key1, key2, key3, key4, key5, key6
string  *  32  array rec_key_list  ( 100, 8 ) |value, key1, key2, key3, key4, key5, key6
integer *   2  array rec_key_list_pointer   ( 8 )      | next row to add to array for each key
string  *  32  array match_value   ( 8 )      | User matching criteria.  Updated when 1st match is encountered
integer *   1  start_key             | which key was clicked
integer *   1  key_refresh_start     | First key to refresh
string  * 150  txt                   | general output for debuggin
integer *   1  first_match           | First row that matched user defined criteria was encountered.  If so set all match values to current row values
string  *  32  current_key_value     | what is the value of this key
integer *   1  previous_keys_match   | if all previous keys match check current key value to see if it is unique
string  *  32  KEY_NAME
integer *   1  KEY_VTYPE
string  *  32  KEY_VALUE             | Key value
string  * 123  KEY_VALUE_LABEL       | Key value label
string  * 123  DISPLAY_TEXT          | text to output to window
|
|
|
|
|
. ENABLE TIMER 600
. set LOGOUTMINUTE (0)
. set HMFIC (1)
. time COUNTDOWN ('HH:MM:SS')
. COUNTDOWN = now(0)
. MEM_O = 4
. MEM_T = 1
. set TEMPKEY1 TEMPKEY2 TEMPKEY3 TEMPKEY4 (smissing)
. set NO   CASE#   (0)
. set YES     (1)
. CASE_$N    = varname(0, 1)
. CASETYPE  = vartype(CASE_$N)
. ANYNUM = upset('fsize','10')
| Dialog items
. set dialog title dbname(0)+" Created by the DCC"
. set item font PTITLE,1,0,0,0,"#000099"
. set item PTITLE [dbname(0)]
. set N_BOLD N_ITALIC N_UNDERL (0)
. set BOLD ITALIC UNDERL SMALL (1)
. set LARGE (3)
. set NPFONT ('lucida console')
. set P_FONT ('arial')
. set item font FIND_SUB , N_BOLD, N_ITALIC, N_UNDERL, SMALL, NPFONT
. set item font SUBJECTS, N_BOLD, N_ITALIC, N_UNDERL, SMALL, NPFONT
. set item font FORMS   , N_BOLD, N_ITALIC, N_UNDERL, SMALL, NPFONT
. set item font KEY1    , N_BOLD, N_ITALIC, N_UNDERL, SMALL, NPFONT
. set item font KEY2    , N_BOLD, N_ITALIC, N_UNDERL, SMALL, NPFONT
. set item font KEY3    , N_BOLD, N_ITALIC, N_UNDERL, SMALL, NPFONT
. set item font KEY4    , N_BOLD, N_ITALIC, N_UNDERL, SMALL, NPFONT
. for ANYNUM = 1, 5
.   set item font BIG_SUBJ,N_BOLD,N_ITALIC,N_UNDERL,1    ,NPFONT
. end for
. set item font SUBJECTL, N_BOLD, N_ITALIC,UNDERL, LARGE, P_FONT
. set item font FORML   , N_BOLD, N_ITALIC,UNDERL, LARGE, P_FONT
. set item font KEY1L   , N_BOLD, N_ITALIC,UNDERL, LARGE, P_FONT
. set item font KEY2L   , N_BOLD, N_ITALIC,UNDERL, LARGE, P_FONT
. set item font KEY3L   , N_BOLD, N_ITALIC,UNDERL, LARGE, P_FONT
. set item font KEY4L   , N_BOLD, N_ITALIC,UNDERL, LARGE, P_FONT
. set item font SUBJINFO, N_BOLD, N_ITALIC,UNDERL, LARGE, P_FONT
. set item SUBJECTL, CASE_$N
. ARRAYSZ# = numcases(0)
. ifthen (exists(ARRAYSZ#) eq NO or ARRAYSZ# eq 0)
.   display textbox "What is the first case" response CANCEL CASE_$V
.   ifthen (CANCEL > NO)
.     EXECUTE SUBPROCEDURE NEW_CASE_ID
.   else
.     write "Can not start with no case ids in database.  Exiting"
.     exit message
.   endif
. endif
| Load the dialog lists
. ifthen (meminfo('NAVIGATE.LOADSUBJECTS:O',1) eq MEM_O)
.   execute subroutine NAVIGATE.LOADSUBJECTS (SUBJECTS) DYNAMIC
. else
.   execute subprocedure LOADSUBJECTS
. endif
. execute subprocedure LOADFORMS | Note that LOADFORM must come first, because LOADKEYS is called by LOADCASE and LOADKEYS needs to check the FORM to load the proper NUMber of keys.
. CLCK_# = 0   |Initial like they clicked on a subject
. execute subprocedure GET_USER_CLICK
. CLCK_# = -1  |then they clicked on a form
. execute subprocedure GET_USER_CLICK
. focus item FIND_SUB
. hide item FIND_SUBB
. hide item TIME_OUT_LABEL
. ifthen (meminfo('NAVIGATE.SETBUTTONS:O',1) eq MEM_O)
.   execute subroutine NAVIGATE.SETBUTTONS DYNAMIC
. else
.   hide item BUTTON1
.   hide item BUTTON2
.   hide item SEARCH_B
. endif
. ifthen (meminfo('NAVIGATE.USERS:O',1) eq MEM_O)
.   execute subroutine NAVIGATE.USERS DYNAMIC
. endif
. hide item STATS_B
. hide item SEARCH_B
|}
end initial

message ALL m_id, m_arg1, m_arg2

|{ Message
LOGOUTMINUTE = 0
<comment> write '----------------   Messages   ----------------' //
|}

ifthen (m_id eq FIND_SUBB )
|< FIND_SUBB
. PROCEED = YES
. ifthen ( getfocus(0) eq FIND_SUB)
.   execute subprocedure GET_CASE_ID
.   ifthen( meminfo('NAVIGATE.CXID:O',1) eq MEM_O)
.     execute subroutine NAVIGATE.CXID (CASE_$V) returning (PROCEED) DYNAMIC
.   endif
.   ifthen (PROCEED eq YES)
.     execute subprocedure FIND_SUBJECT | (CASE_$V)
.     ifthen (FOUNDID eq YES)
.       CLCK_# = 0
.       execute subprocedure GET_USER_CLICK
.       focus item FORMS
.     else
.       display yncbox CASE_$V + " does not exist, do you want to create it? ", response RESVAR   | 3.
.       if (RESVAR eq 1) execute subprocedure CREATE_NEW_CASE; set item FIND_SUB,''
.     endif
.   else
.     display infobox 'This ID is not valid'
.   endif
. endif
|>
next message
endif

ifthen (m_id eq SUBJECTS )
|< SUBJECTS
| The user selected a subject...
. CLCK_# = 0
. execute subprocedure GET_USER_CLICK
|>
next message
endif

ifthen (m_id eq FORMS )
|< FORMS
. CLCK_# = -1 |Forms
. execute subprocedure GET_USER_CLICK
. SCR$N = gettxt(FORMS)
|
|
|
|
c new code here for testing debug

write ' --------------    new run    --------------'
start_key = 1          | because SIR does complex things to CASE and CASESLESS DB we pass in a start value and change as needed.
write 'SIR key count: ' KEY#C
KEY#C = nkeys(REC_#) + dbtype(0)
execute subprocedure SET_KEY_REFRESH_START
execute subprocedure ["get_rec_" + format(REC_#)]
write 'total rows in db record type: ' db_row
write 'key refresh starts at: ' key_refresh_start ' which is actually key: ' start_key
execute subprocedure VIEW_ALL_KEYS
ifthen (KEY#C ge 1)
. execute subprocedure CREATE_MATCHED_KEY_ARRAYS
else
. write 'no keys.  no updates needed'
. next message
endif
execute subprocedure REFRESH_KEYS
|
|
|
|


|>
next message
endif

ifthen (m_id eq KEY1 )
|< KEY1
. CLCK_# = 1
. execute subprocedure GET_USER_CLICK


|
|
c new code here for testing debug

write ' --------------    new run    --------------'
execute subprocedure SET_MATCH_VALUES
start_key = 2          | because SIR does complex things to CASE and CASESLESS DB we pass in a start value and change as needed.
write 'SIR key count: ' KEY#C
KEY#C = nkeys(REC_#) + dbtype(0)
execute subprocedure SET_KEY_REFRESH_START
execute subprocedure ["get_rec_" + format(REC_#)]
write 'total rows in db record type: ' db_row
write 'key refresh starts at: ' key_refresh_start ' which is actually key: ' start_key
execute subprocedure VIEW_ALL_KEYS
ifthen (KEY#C ge 1)
. execute subprocedure CREATE_MATCHED_KEY_ARRAYS
else
. write 'no keys.  no updates needed'
. next message
endif
execute subprocedure REFRESH_KEYS
|
|
|
|



|>
next message
endif

ifthen (m_id eq KEY2 )
|< KEY2
. CLCK_# = 2
. execute subprocedure GET_USER_CLICK
|>
next message
endif

ifthen (m_id eq KEY3 )
|< KEY3
. CLCK_# = 3
. execute subprocedure GET_USER_CLICK
|>
next message
endif

ifthen (m_id eq KEY4 )
|< KEY4
. CLCK_# = 4
. execute subprocedure GET_USER_CLICK
|>
next message
endif

ifthen (m_id eq ADDNEWF )
|< ADDNEWF
. PROCEED = YES
. ifthen (meminfo('NAVIGATE.ADDNEWF:O',1) eq MEM_O)
.   SCR$N = gettxt(FORMS)
.   execute subroutine NAVIGATE.ADDNEWF (CASE_$V SCR$N) returning (PROCEED) DYNAMIC
. endif
. ifthen (PROCEED eq YES)
. ifthen (nkeys(REC_#) eq NO)            |No keys.  The other side is what to do if there are keys.
.   execute subprocedure GOTO_SCREEN
.   CLCK_# = -1   |Forms
.   execute subprocedure GET_USER_CLICK  | Refresh display in either case to get correct record count
c. elseif (nvalid(REC_#,keyname(REC_#,2)) eq 1) | If there is a key, but only 1 valid value, go directly to the data entry screen with the appropriate key value
c.   KEY$1 = format(nvval(REC_#,keyname(REC_#,2),1))
c.   execute subprocedure GOTO_SCREEN
. else
.   execute subprocedure MAKE_TEMP_KEYS   | Make temp keys before you go, so if they cancel you can reposition to previous choice.
.   execute subprocedure PICKKEY          | Note: temp Keys is called again here.  And it calls a data entry screen.

.   CLCK_# = -1   |Forms                  | repaint the screen and find out how many forms there are now
.   execute subprocedure GET_USER_CLICK        | Refresh display in either case to get correct record count

.   ifthen (PASSCHCK eq 1)                 | REFRESH data lists. User did all keys correctly and went into a data form.
c       cycle through the possible values for KEY1 then KEY2 then KEY3 then KEY4 and select when found
.     REPNT$   = 0  | If adding a new record and the keys can not be found in the list, repaint all keys (sorry user)
.     NOMORE$  = 0  | if 1:  EXIT MESSAGE
.     FIND_KEY = 0  | Start with NOT in list.
.     for EACH_ITEM = 1, getnitem(KEY1)
.       POS = abs(srst(getitxt(KEY1,EACH_ITEM), ' '))-1  | A space indicates that value labels were added
.       if (POS < 0) POS = len(getitxt(KEY1,EACH_ITEM))
.       KEY$V = sbst(getitxt(KEY1,EACH_ITEM), 1, POS)
.       ifthen (KEY$V eq TEMPKEY1)
.         FIND_KEY = 1   | Found the value.  It is OK to CANCEL.
.         exit for
.       endif
.     end for
.     ifthen (FIND_KEY eq 1) | Found value. OK to continue.
.       select item KEY1,EACH_ITEM
.       if (NKEYS(REC_#) eq 1) NOMORE$ = 1
.     else
.       REPNT$ = 1
.     endif
|
.     if (NOMORE$ eq 1) next message
.     execute subprocedure REFRESH_KEY2

.     FIND_KEY = 0  | SAME AS ABOVE BUT USING NEXT KEY.
.     for EACH_ITEM=1, getnitem(KEY2)
.       POS = abs(srst(getitxt(KEY2,EACH_ITEM), ' '))-1  | A space indicates that value labels were added
.       if (POS < 0) POS = len(getitxt(KEY2,EACH_ITEM))
.       KEY$V = sbst(getitxt(KEY2,EACH_ITEM), 1, POS)
.       ifthen (KEY$V eq TEMPKEY2)
.         FIND_KEY = 1   | Found the value.  It is OK to continue.
.         exit for
.       endif
.     end for
.     ifthen (FIND_KEY eq 1) | Found value. OK to continue.
.       select item KEY2,EACH_ITEM
.       if (NKEYS(REC_#) eq 2) NOMORE$ = 1
.     else
.       REPNT$ = 1
.     endif
|
.     if (NOMORE$ eq 1) next message
.     execute subprocedure REFRESH_KEY3

.     FIND_KEY = 0  | SAME AS ABOVE BUT USING NEXT KEY.
.     for EACH_ITEM=1, getnitem(KEY3)
.       POS = abs(srst(getitxt(KEY3,EACH_ITEM), ' '))-1  | A space indicates that value labels were added
.       if (POS < 0) POS = len(getitxt(KEY3,EACH_ITEM))
.       KEY$V = sbst(getitxt(KEY3,EACH_ITEM), 1, POS)
.       ifthen (KEY$V eq TEMPKEY3)
.         FIND_KEY = 1   | Found the value.  It is OK to continue.
.         exit for
.       endif
.     end for
.     ifthen (FIND_KEY eq 1) | Found value. OK to continue.
.       select item KEY3,EACH_ITEM
.       if (NKEYS(REC_#) eq 3) NOMORE$ = 1
.     else
.       REPNT$ = 1
.     endif
|
.     if (NOMORE$ eq 1) next message
.     execute subprocedure REFRESH_KEY4

.     FIND_KEY = 0  | SAME AS ABOVE BUT USING NEXT KEY.
.     for EACH_ITEM=1, getnitem(KEY4)
.       POS = abs(srst(getitxt(KEY4,EACH_ITEM), ' '))-1  | A space indicates that value labels were added
.       if (POS < 0) POS = len(getitxt(KEY4,EACH_ITEM))
.       KEY$V = sbst(getitxt(KEY4,EACH_ITEM), 1, POS)
.       ifthen (KEY$V eq TEMPKEY4)
.         FIND_KEY = 1   | Found the value.  It is OK to continue.
.         exit for
.       endif
.     end for
.     ifthen (FIND_KEY eq 1) | Found value. OK to continue.
.       select item KEY4,EACH_ITEM
.     else
.       REPNT$ = 1
.     endif
|
.     if (NOMORE$ eq 1) next message
.     ifthen (REPNT$ eq 1)
.       CLCK_# = -1   |Forms                  | repaint the screen and find out how many forms there are now
.       execute subprocedure GET_USER_CLICK        | Refresh display in either case to get correct record count
.     endif
.   endif
. endif
. endif
|>
next message
endif

ifthen (m_id eq TEMPEXIT )
|< TEMPEXIT
exit message
|>
next message
endif

ifthen (m_id eq STATS_B )
|< STATS_B
c. ifthen (trimr(gettxt(STATS_B)) eq '&List Stats')
.    execute subprocedure GET_CASE_ID
c.   CASE_$V = CASE_A(getpos(SUBJECTS))
c.   execute dbms "CALL DCCPROCF.BASE.MSTCLEAR"
c.   execute subroutine DCCPROCF.UTIL.LISTONE (CASE_$V CASETYPE SUBJECTS)
c.   execute subroutine DCCPROCF.UTIL.LIST_IT (CASE_$V) DYNAMIC
c.   execute dbms "CALL DCCPROCF.BASE.MSTSET"
c. endif
|>
next message
endif

ifthen (m_id eq SEARCH_B )
|< SEARCH_B
execute dbms "Call dccprocf.search.general2"
|>
next message
endif

ifthen (m_id eq BUTTON1 )
|< BUTTON1
. CLICK = YES
. execute subroutine NAVIGATE.BUTTON1 (BUTTON1 CLICK) returning (BUTTON1$) DYNAMIC
|>
next message
endif

ifthen (m_id eq BUTTON2 )
|< BUTTON2
. execute subroutine NAVIGATE.BUTTON2 (BUTTON2) returning (BUTTON2$) DYNAMIC
|>
next message
endif

if (m_id eq 0) exit message

end message

message TIMER
|{ Timer
. set item TIME_OUT_LABEL 'Minutes until time out: ' +format(10-LOGOUTMINUTE)
. LOGOUTMINUTE = LOGOUTMINUTE+1
. ifthen (LOGOUTMINUTE lt 9) hide item TIME_OUT_LABEL
. elseif (LOGOUTMINUTE eq 9) show item TIME_OUT_LABEL
. elseif(LOGOUTMINUTE gt 10) execute dbms "CALL DCCPROCF.EXIT.MAIN"
. endif
|}
end message

end dialog
|{ Exit
. ifNOTthen (nglobal('GSECLEV') eq HMFIC)
.   execute dbms 'call DCCPROCF.EXIT.MAIN'
c .   pql exit dbms  | this line is redundant.
. endif
|}
|{ Footer
subprocedure LOADFORMS
<comment> write 'sub: LOADFORMS'
. execute subprocedure GET_CASE_ID
c . CASE_$V  = trimlr(gettxt(SUBJECTS))
. ifthen (meminfo('NAVIGATE.LOADFORM:O',1) eq MEM_O)
.   execute subroutine NAVIGATE.LOADFORM (CASE_$V) DYNAMIC
.   SCR$N = gettxt(FORMS)
. else
.   for REC_# = 1, nrecs(0)
.     ifthen (len(recname(REC_#)) gt 0)
.       ifthen (len(trimlr(recname(REC_#))) lt 10)
.         compute RECNM$ = pad(recname(REC_#),' ', 10, 10)
.       else
.         compute RECNM$ = trimlr(recname(REC_#)) + ' ' | space is very important!  Don't touch.
.       endif
.       DOC$  = ' '
.       ifthen (exists(recdoc(REC_#,0)) eq YES and len(recdoc(REC_#,0)) > 0)
.         DOC$ = trimlr(replace(recdoc(REC_#,0),char(9),'',5,0,0)) | Get rid of tabs in the DOCUMENT line
.       elseif (exists(recdoc(REC_#,1)) eq YES)
.         DOC$ = trimlr(replace(recdoc(REC_#,1),char(9),'',5,0,0)) | Get rid of tabs in the DOCUMENT line
.       endif
.       append item FORMS, RECNM$ + DOC$
.     endif
.   end for
. endif
end subprocedure LOADFORMS
|
subprocedure LOAD_SUBJ_INFO
<comment> write 'sub: LOAD_SUBJ_INFO'
<comment> write '       -NAVIGATE.SUBJINFO'
. ifthen (meminfo('NAVIGATE.SUBJINFO:O',1) eq MEM_O)
.  execute subprocedure GET_CASE_ID
c .  CASE_$V = trim(CASE_A(getpos(SUBJECTS)))
.  execute subroutine NAVIGATE.SUBJINFO (SUBJINFO CASE_$V) DYNAMIC
. else
.  hide item SUBJINFO
. endif
end subprocedure LOAD_SUBJ_INFO
|
subprocedure GOTO_SCREEN
<comment> write 'sub: GOTO_SCREEN'
. PROCEED = YES
. ifthen (meminfo('NAVIGATE.GOTOSCREEN:O',1) eq MEM_O)
.   execute subroutine NAVIGATE.GOTOSCREEN:O (CASE_$V KEY$1 KEY$2 KEY$3 KEY$4 SCR$N BUTTON1$) returning (PROCEED) DYNAMIC
. endif
. ifthen (exists(CASE_$V) eq 0 or len(trim(CASE_$V)) eq 0)
.   execute subprocedure GET_CASE_ID
c .   CASE_$V = trimlr(gettxt(SUBJECTS))
. endif
. ifthen (PROCEED eq YES)
.   SCR$N   = trimlr(recname(REC_#))
.   SCRMEM$N = 'SCREENS.'  + trimlr(recname(REC_#)) + ':O'| Construct the name of the FAMILY.MEMBER that you want to call...
.   ifthen (REC_# le 9)
.     REC_$ = '00' + format(REC_#)
.   elseif (REC_# le 99)
.     REC_$ = '0' + format(REC_#)
.   endif
.   DVPMEM$N = 'FORMS.SCRN_' + REC_$ + ':O'| Construct the name of the FAMILY.MEMBER that you want to call...
<comment> WRITE 'PASSING   ' CASE_$V 15t KEY$1 30t KEY$2 45t KEY$3 60t KEY$4
.   ifthen (meminfo(DVPMEM$N, 1) eq MEM_O)
.     execute subroutine [DVPMEM$N] (1,1, CASE_$V, KEY$1, KEY$2, KEY$3, KEY$4, KEY$5, KEY$6, KEY$7) returning (EXIT__#) DYNAMIC
.   elseif (meminfo(SCRMEM$N, 1) eq MEM_O)
.     execute subroutine [SCRMEM$N] (CASE_$V, KEY$1, KEY$2, KEY$3, KEY$4, KEY$5, KEY$6) DYNAMIC
.   else
.     display infobox "Please contact Administrator.  "+ pack(recname(REC_#)) + " is not available"
.   endif
. endif
. focus item FIND_SUB
end subprocedure GOTO_SCREEN
|
subprocedure LOAD_VALUE
C MULTIPLE CALLS.  1 FOR EACH KEY.
<comment> write 'sub: LOAD_VALUE'
<comment> write 'sub:    - MAKE_KEYBUFF'
. execute subprocedure GET_CASE_ID
. KEY#T = vtype(REC_#, keyname(REC_#, OURKEY#))
. ifthen (exists(gettxt(KEY1)) eq 0 or gettxt(KEY1) ne 'No data')   | there is a reason to process the records
.   execute subprocedure MAKE_KEYBUFF
. endif
end subprocedure LOAD_VALUE
|
subprocedure REMOVEALL
<comment> write 'sub: REMOVEALL'
. remove all   KEY1
. remove all   KEY2
. remove all   KEY3
. remove all   KEY4
end subprocedure REMOVEALL
|
subprocedure HIDEALL
<comment> write 'sub: HIDEALL'
. remove all   KEY1
. hide item    KEY1
. set item     KEY1L,''
. remove all   KEY2
. hide item    KEY2
. set item     KEY2L,''
. remove all   KEY3
. hide item    KEY3
. set item     KEY3L,''
. remove all   KEY4
. hide item    KEY4
. set item     KEY4L,''
end subprocedure HIDEALL
|
subprocedure MAKE_KEYBUFF
. ifthen (exists(CASE_$V) eq 0 or len(trim(CASE_$V)) eq 0)
.   execute subprocedure GET_CASE_ID
. endif
<comment> write 'sub: MAKE_KEYBUFF'
| when cycling thru the records you must remember the last key, check it to current value and see if different.  Use TEMP_$
. compute REC_#C = 0  |How many records exists for that case
. BUFF$N = 'KEYBUFF'
. execute subprocedure CREATE_BUFFER
. BUFF$ = 'retrieval'  <RTB>
. BUFF$ = '. string * 32 TEMP_$ SHOW_$' <RTB>
. BUFF$ = ". set SHOW_$ TEMP_$ (' ')" <RTB>
. BUFF$ = '. old case is '; execute subprocedure ADD_CASE_ID_TO_BUFFER_LINE <RTB>
. BUFF$ = '.   set item ' + format(REC_CNTL)
          + ',format(count(' + format(REC_#) + '))'  <RTB>
. BUFF$ = '.   set item ' + format(FORMCNT)
          + ',format(count(' + format(REC_#) + ')) '
          + ' + " " + pack(recname(' + format(REC_#) + ')) '  <RTB>
. BUFF$ = '.   ifthen ((0 eq nkeys(' + format(REC_#) +')) '
          + 'and (count(' + format(REC_#) + ') eq 1)) hide item ' +format(ADDNEWF) <RTB>
. BUFF$ = '.   else  show item ' + format(ADDNEWF)  <RTB>
. BUFF$ = '.   endif'  <RTB>
. BUFF$ = '.   set item ' +format(ADDNEWF)
          +',  "New " + pack(recname(' + format(REC_#) + ')) + " Form"'  <RTB>
. BUFF$ = '.   set item ' + format(BIG_SUBJ)+ ','
. execute subprocedure ADD_CASE_ID_TO_BUFFER_LINE  <RTB>
ifthen (nkeys(REC_#) gt 0)  |This is indented to stand out.  No Keys needs something special because D_ITEM_# will not work.
. BUFF$ = '.   process rec ' + format(REC_#) + ' ' + VIA_$  <RTB>
. ifthen (vtype(REC_#, keyname(REC_#, OURKEY#+1)) eq 3)
.   BUFF$ =  '.   SHOW_$ = replace(varget(keyname(' + format(REC_#) + ', ' + format(OURKEY#+1) + '))," ","/",2,0,0)'
. elseif (vtype(REC_#, keyname(REC_#, OURKEY#+1)) eq 4)
.   BUFF$ =  '.   SHOW_$ = replace(varget(keyname(' + format(REC_#) + ', ' + format(OURKEY#+1) + '))," ",":",3,0,0)'
. else
.   BUFF$ =  '.   SHOW_$ =  trimlr(varget(keyname(' + format(REC_#) + ', ' + format(OURKEY#+1) + ')))'
. endif
. execute subprocedure WRITE_TO_BUFFER
. BUFF$ =  '.     ifthen (trimlr(TEMP_$) ne trimlr(SHOW_$))'  <RTB>
. BUFF$ =  '.       append item ' + format(D_ITEM_# ) + ', pack(SHOW_$)'
           + '+"  "+trim(fst(vallab(' + pack(keyname(REC_#,OURKEY#+1)) + '),""))'  <RTB>
. BUFF$ = '.      endif'  <RTB>
. BUFF$ = '.     TEMP_$ = SHOW_$'  <RTB>
. BUFF$ = '.   end rec'  <RTB>
endif
. BUFF$ = '. end case'  <RTB>
. BUFF$ = 'end retrieval'  <RTB>
. execute dbms ['INCLUDE BUFFER ' + BUFF$N]
c
. if (gettxt(D_ITEM_#) eq '' or exists(gettxt(D_ITEM_#)) eq 0 and NKEYS(REC_#) > 0) append item D_ITEM_#, "No data"
.
end subprocedure
|
subprocedure PICKKEY
<comment> write 'sub: PICKKEY'
. integer*1 CLOSER   ; CLOSER   =0
. integer*1 CANCEL_X ; CANCEL_X =1
. integer*1 NEWKEY1  ; NEWKEY1  =2
. integer*1 NEWKEY1L ; NEWKEY1L =3
. integer*1 NEWKEY1E ; NEWKEY1E =4
. integer*1 NEWKEY1H ; NEWKEY1H =5
. integer*1 NEWKEY2  ; NEWKEY2  =6
. integer*1 NEWKEY2L ; NEWKEY2L =7
. integer*1 NEWKEY2E ; NEWKEY2E =8
. integer*1 NEWKEY2H ; NEWKEY2H =9
. integer*1 NEWKEY3  ; NEWKEY3  =10
. integer*1 NEWKEY3L ; NEWKEY3L =11
. integer*1 NEWKEY3E ; NEWKEY3E =12
. integer*1 NEWKEY3H ; NEWKEY3H =13
. integer*1 NEWKEY4  ; NEWKEY4  =14
. integer*1 NEWKEY4L ; NEWKEY4L =15
. integer*1 NEWKEY4E ; NEWKEY4E =16
. integer*1 NEWKEY4H ; NEWKEY4H =17
. integer*1 SELECTL  ; SELECTL  =18
. integer*1 B_ADD1   ; B_ADD1   =51
. integer*1 B_ADD2   ; B_ADD2   =52
. integer*1 B_ADD3   ; B_ADD3   =53
. integer*1 B_ADD4   ; B_ADD4   =54
. dialog "Select keys.  "
|   LIST    id      ,row ,   height, col, width ,type
|   LABEL   id      ,row ,           col, width,text
.   postype 1
.   line    IDSTATIC,  0, 370,   0, 490
.   button  CANCEL_X,  5,      430,  40, 1, "Cancel"
.   button  B_ADD1  , 60,        30, 120, 0, "2.  Go to form"
.   button  B_ADD2  , 155,       30, 120, 0, "3.  Go to form"
.   button  B_ADD3  , 250,       30, 120, 0, "4.  Go to form"
.   button  B_ADD4  , 340,       30, 120, 0, "5.  Go to form"
.   label   SELECTL ,   5,      200, 160,    "Or select a value from these choices"
.   label   NEWKEY1L,   5,       30, 160,    "Displays Key Label"
.   edit    NEWKEY1E,  20,       30, 120, 0,0
.   label   NEWKEY1H,  40,       30, 160,    "Displays Help information"
.   list    NEWKEY1 ,  20,  60, 200, 210, 0
.   label   NEWKEY2L, 100,       30, 160,    "Displays Key Label"
.   edit    NEWKEY2E, 115,       30, 120, 0,0
.   label   NEWKEY2H, 135,       30, 160,    "Displays Help information"
.   list    NEWKEY2 , 115,  60, 200, 210, 0
.   label   NEWKEY3L, 195,       30, 160,    "Displays Key Label"
.   edit    NEWKEY3E, 210,       30, 120 , 0,0
.   label   NEWKEY3H, 230,       30, 160,    "Displays Help information"
.   list    NEWKEY3 , 210,  60, 200, 210, 0
.   label   NEWKEY4L, 290,       30, 160,    "Displays Key Label"
.   edit    NEWKEY4E, 305,       30, 120, 0,0
.   label   NEWKEY4H, 325,       30, 160,    "Displays Help information"
.   list    NEWKEY4 , 305,  60, 200, 210, 0
.   initial
.     string  * 200  TXT$
.     integer *   4  HOWMANY#
.     PASSCHCK = 0 | it is funny.  I set this to 0 and then set it later to 1 It works.  It is designed that way.
.     set item font NEWKEY1L, N_BOLD, N_ITALIC,UNDERL, LARGE, P_FONT
.     set item font NEWKEY2L, N_BOLD, N_ITALIC,UNDERL, LARGE, P_FONT
.     set item font NEWKEY3L, N_BOLD, N_ITALIC,UNDERL, LARGE, P_FONT
.     set item font NEWKEY4L, N_BOLD, N_ITALIC,UNDERL, LARGE, P_FONT
.     set item font NEWKEY1H,N_BOLD,N_ITALIC,N_UNDERL,0,NPFONT
.     set item font NEWKEY2H, N_BOLD, N_ITALIC, N_UNDERL, SMALL, NPFONT
.     set item font NEWKEY3H, N_BOLD, N_ITALIC, N_UNDERL, SMALL, NPFONT
.     set item font NEWKEY4H, N_BOLD, N_ITALIC, N_UNDERL, SMALL, NPFONT
.     set item font NEWKEY1E, N_BOLD, N_ITALIC, N_UNDERL, SMALL, NPFONT
.     set item font NEWKEY2E, N_BOLD, N_ITALIC, N_UNDERL, SMALL, NPFONT
.     set item font NEWKEY3E, N_BOLD, N_ITALIC, N_UNDERL, SMALL, NPFONT
.     set item font NEWKEY4E, N_BOLD, N_ITALIC, N_UNDERL, SMALL, NPFONT
.     focus item NEWKEY1E
.     ifthen (nkeys(REC_#) eq 1)
.       hide item B_ADD2
.       hide item NEWKEY2
.       hide item NEWKEY2L
.       hide item NEWKEY2E
.       hide item NEWKEY2H
.       hide item B_ADD3
.       hide item NEWKEY3
.       hide item NEWKEY3L
.       hide item NEWKEY3E
.       hide item NEWKEY3H
.       hide item B_ADD4
.       hide item NEWKEY4
.       hide item NEWKEY4L
.       hide item NEWKEY4E
.       hide item NEWKEY4H
.     elseif (nkeys(REC_#) eq 2)
.       hide item B_ADD1
.       hide item B_ADD3
.       hide item B_ADD4
.       hide item NEWKEY3
.       hide item NEWKEY3L
.       hide item NEWKEY3E
.       hide item NEWKEY3H
.       hide item B_ADD4
.       hide item NEWKEY4
.       hide item NEWKEY4L
.       hide item NEWKEY4E
.       hide item NEWKEY4H
.     elseif (nkeys(REC_#) eq 3)
.       hide item B_ADD1
.       hide item B_ADD2
.       hide item B_ADD4
.       hide item NEWKEY4
.       hide item NEWKEY4L
.       hide item NEWKEY4E
.       hide item NEWKEY4H
.     elseif (nkeys(REC_#) eq 4)
.       hide item B_ADD1
.       hide item B_ADD2
.       hide item B_ADD3
.     endif
.     HOWMANY# = 0  | TOTAL COUNT OF HOW MANY ITEMS ARE APPENDED TO A LIST
.     set KEY$1 KEY$2 KEY$3 KEY$4 (missing)
.     for OURKEY#=1,nkeys(REC_#)
.       KEY$N   = keyname(REC_#, (OURKEY#+1))
.       LAB_CNT = nvallab(REC_#, KEY$N)
.       KEYMIN  = nmin   (REC_#, KEY$N)          | The minimum range of the key, if there is one
.       KEYMAX  = nmax   (REC_#, KEY$N)          | The maximum range of the key, if there is one
.       VTYPE_# = vtype  (REC_#, KEY$N)
.       TXT$ = format(OURKEY#)+ ". Enter a new "
.       ifthen (len(pack(varlabsc(REC_#,KEY$N))) gt 0 )
.         TXT$ = TXT$ + pack(varlabsc(REC_#,KEY$N))
.       else
.         TXT$ = TXT$ + KEY$N
.       endif
.       if ( OURKEY#  eq 1) D_ITEM_# = NEWKEY1;  set item NEWKEY1L, TXT$ ; enable item NEWKEY1
.       if ( OURKEY#  eq 2) D_ITEM_# = NEWKEY2;  set item NEWKEY2L, TXT$ ; enable item NEWKEY2
.       if ( OURKEY#  eq 3) D_ITEM_# = NEWKEY3;  set item NEWKEY3L, TXT$ ; enable item NEWKEY3
.       if ( OURKEY#  eq 4) D_ITEM_# = NEWKEY4;  set item NEWKEY4L, TXT$ ; enable item NEWKEY4
.         TXT$ = ''
.       ifthen (VTYPE_# eq 3)
.         TXT$ = substr( vformat(REC_#,key$n),2,len(vformat(REC_#,key$n)))
.         TXT$ = replace(TXT$ ,':','/',4,1,0)
.       elseif (VTYPE_# eq 4)
.         TXT$ = substr( vformat(REC_#,key$n),2,len(vformat(REC_#,key$n)))
.       endif
.       if ( OURKEY#  eq 1) set item NEWKEY1H,TXT$
.       if ( OURKEY#  eq 2) set item NEWKEY2H,TXT$
.       if ( OURKEY#  eq 3) set item NEWKEY3H,TXT$
.       if ( OURKEY#  eq 4) set item NEWKEY4H,TXT$
c ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
.       ifthen (nvalid(REC_#, KEY$N) ne 0 and LAB_CNT eq 0) | Valid values without labels
.         VALID_# = 0
.         for VALID_# = 1, nvalid(REC_#, KEY$N)
.           append item D_ITEM_#, pad(format(nvval(REC_#, KEY$N, VALID_#)),' ',6,6)
.         end for
.       elseif (vtype(REC_#, KEY$N) eq 2)                    | Categorical
.         VALID_# = 0
.         while (VALID_# lt LAB_CNT)                        | Use the categorical value after appending its numeric value in front...
.           VALID_# = VALID_# + 1
.           append item D_ITEM_#, pad(format(VALID_#),' ',6,6) + pad(pack(vallabsv(REC_#, KEY$N, VALID_#)),' ',6,6) + ' ' + pack(vallabsn(REC_#, KEY$N, VALID_#))
.         end while
.       elseif (LAB_CNT gt 0)                              | Value labels. If there are labels, use them...
.         VALID_# = 0
.         while (VALID_# lt LAB_CNT)
.           VALID_# = VALID_# + 1
.           append item D_ITEM_#, pad(pack(vallabsv(REC_#, KEY$N, VALID_#)),' ',6,6) + ' ' + pack(vallabsn(REC_#, KEY$N, VALID_#))
.         end while
.       elseif ((KEYMAX - KEYMIN) le 1000)                   | If there aren't labels but there is a reasonable range, use that...
.         for MINTOMAX = KEYMIN, KEYMAX
.           append item D_ITEM_#, format(MINTOMAX)
.         end for
.       else                  | If you get here, then check the record for actual values, unless the previous key was a Q_MARK mark.
.         hide item D_ITEM_#
.       endif
.       compute HOWMANY# = HOWMANY#+getnitem(D_ITEM_#)
.     end for
.     ifthen (HOWMANY# eq 0)
.       hide item SELECTL
.     endif
.   end initial
.   message ALL m_id, m_arg1, m_arg2
.     ifthen (m_id eq B_ADD1 or B_ADD2 or B_ADD3 or B_ADD4 )
.       execute subprocedure TEST_VALUES
.       ifthen (PASSCHCK eq 1)  |Passed all the checks!
write '6. Checking ' KEY$2
.         execute subprocedure MAKE_TEMP_KEYS
.         execute subprocedure GOTO_SCREEN
.         exit message  | make sure you exit back to main navigation screen
.       endif
.     endif
.     ifthen (m_id eq CANCEL_X)  |I'm going to use the Cancel box as the default button to see where the user is.
.       ifthen (GETFOCUS(0) eq 1)
.         exit message
.       elseif (getfocus(0) eq NEWKEY1E)
.         focus item NEWKEY2E
.         if (nkeys(REC_#) eq 1) focus item B_ADD1
.       elseif (getfocus(0) eq NEWKEY2E)
.         focus item NEWKEY3E
.         if (nkeys(REC_#) eq 2) focus item B_ADD2
.       elseif (getfocus(0) eq NEWKEY3E)
.         focus item NEWKEY4E
.         if (nkeys(REC_#) eq 3) focus item B_ADD3
.       elseif (getfocus(0) eq NEWKEY4E)
.         focus item B_ADD1
.         if (nkeys(REC_#) eq 4) focus item B_ADD4
.       elseif (getfocus(0) eq B_ADD1 OR B_ADD2 OR B_ADD3 OR B_ADD4)
.         execute subprocedure TEST_VALUES
.         ifthen (PASSCHCK eq 1)  |Passed all the checks!
.           execute subprocedure MAKE_TEMP_KEYS
.           execute subprocedure GOTO_SCREEN
.           exit message  | make sure you exit back to main navigation screen
.         endif
.       endif
.     endif
.     ifthen (m_id eq NEWKEY1)
.       set item NEWKEY1E,gettxt(NEWKEY1)
.       focus item NEWKEY2E
.     endif
.     ifthen (m_id eq NEWKEY2)
.       set item NEWKEY2E,gettxt(NEWKEY2)
.       focus item NEWKEY3E
.     endif
.     ifthen (m_id eq NEWKEY3)
.       set item NEWKEY3E,gettxt(NEWKEY3)
.       focus item NEWKEY4E
.     endif
.     ifthen (m_id eq NEWKEY4)
.       set item NEWKEY4E,gettxt(NEWKEY4)
.     endif
.     if (m_id eq 0) exit message
.   end message
. end dialog
end subprocedure
|
subprocedure TEST_VALUES  |IT RETURNS PASSCHCK = 1 GOOD KEYS
<comment> write 'subprocedure TEST_VALUES'
. for OURKEY#=1,nkeys(REC_#)
.   compute PASSCHCK = 1  |lets assume everything is all right.
.   KEY$N   = keyname(REC_#, (OURKEY#+1))
.   if ( OURKEY#  eq 1) KEY$V = gettxt(NEWKEY1E)
.   if ( OURKEY#  eq 2) KEY$V = gettxt(NEWKEY2E)
.   if ( OURKEY#  eq 3) KEY$V = gettxt(NEWKEY3E)
.   if ( OURKEY#  eq 4) KEY$V = gettxt(NEWKEY4E)
string * 30 CAT$V  | 2. Temporary solution for handling CAT VARS
.   CAT$V = trimlr(sbst(KEY$V, abs(srst(KEY$V,' ')),3))
.   ifthen (vtype(REC_#,KEY$N) ne 3) | A date
.     POS = abs(srst(KEY$V, ' '))-1  | A space indicates that value labels were added
.     if (POS < 0) POS = len(KEY$V)
.     KEY$V = sbst(KEY$V, 1, POS)
.   else                             | If it is a date, replace the spaces with /
.     KEY$V = replace(KEY$V,' ','/',2,2,0)
.   endif
.   ifthen (vtype(REC_#,KEY$N) eq 1)  | string
.     ifthen (numbr(substr(vformat(REC_#,KEY$N),1,len(vformat(REC_#,KEY$N)))) gt len(KEY$V))
.       display infobox "Stop!  "+KEY$N+ ' That is too long'
.       compute PASSCHCK = 0
.     end if
.   else if (vtype(REC_#,KEY$N) eq 2)  | categorical
.     compute GOODCAT = 0
.     for N=1,nvalid(REC_#,KEY$N)  |must cycle thru and get values instead of use "catint"
.       if (svval(REC_#,KEY$N, N ) eq  CAT$V )   compute GOODCAT=1; exit for    |VALID VALUE 2.
.     end for
.     ifthen (GOODCAT eq 0)
.       display infobox "1. Stop!  "+KEY$N+ " cannot be equal to that."
.       compute PASSCHCK=0
.     end if
.   else if (vtype(REC_#,KEY$N) eq 3)  |its a date so check the format.
.     compute TYPEDATE = datemap(REC_#,KEY$N)
.     compute TYPEDATE = replace(TYPEDATE,'E','',1,1,0)
.     compute TYPEDATE = replace(TYPEDATE,'M','d',4,1,0)
.     compute TYPEDATE = replace(TYPEDATE,'D','d',4,1,0)
.     compute TYPEDATE = replace(TYPEDATE,'Y','d',4,1,0)
.     compute TYPEDATE = replace(TYPEDATE,'/','x',4,1,0)
.     compute TYPEDATE = replace(TYPEDATE,'-','x',4,1,0)
.     ifthen (picture(KEY$V,TYPEDATE) ne 0) compute PASSCHCK=0
.       display infobox "Stop!  " + trim(KEY$N) + " is "+ datemap(REC_#,KEY$N)
.       exit subprocedure
.     endif
.   else if (vtype(REC_#,KEY$N) eq 4)  |its a date so check the format.
.     compute TYPETIME = timemap(REC_#,KEY$N)
.     compute TYPETIME = replace(TYPETIME,'H','d',4,1,0)
.     compute TYPETIME = replace(TYPETIME,'M','d',4,1,0)
.     compute TYPETIME = replace(TYPETIME,'S','d',4,1,0)
.     compute TYPETIME = replace(TYPETIME,':','x',4,1,0)
.     if (picture(KEY$V,TYPETIME) ne 0)  compute PASSCHCK=0
.     if (PASSCHCK eq 0) display infobox "Stop!  "+KEY$N + " is "+ timemap(REC_#,KEY$N)
.   else if (vtype(REC_#,KEY$N) eq 5 or 6 or 7 or 8)  |its an integer
.     ifthen (exists(numbr(KEY$V)) eq 0)
.       display infobox "Stop!  "+KEY$N+ "must be a number!"
.       compute PASSCHCK = 0
.     else if (nmax(REC_#,KEY$N) lt numbr(KEY$V))
.       compute PASSCHCK = 0
.       display infobox "Stop!  "+KEY$N+ " must be below "+format(nmax(REC_#,KEY$N))
.     else if (nmin(REC_#,KEY$N) gt numbr(KEY$V))
.       compute PASSCHCK = 0
.       display infobox "Stop!  "+KEY$N+ " must be above "+format(nmin(REC_#,KEY$N))
.     end if
.   end if
.   ifthen (len(KEY$V) GT 44)
.     compute PASSCHCK = 0
.     display infobox "Stop!  "+KEY$N+ " Shoot D.B.A."
.   end if
.   ifthen (vtype(REC_#,KEY$N) eq 2)  | catagorical
.     ifthen (validate (REC_#, KEY$N,svval(REC_#,KEY$N, N)) NE 0)
.       compute PASSCHCK = 0
.       display infobox "Stop!  "+KEY$N+ " cannot be that value. (Cat. Var.)"
.     endif
.     else
.     ifthen (validate (REC_#, KEY$N,KEY$V) NE 0)
.       compute PASSCHCK = 0
.       display infobox "2. Stop!  "+KEY$N+ " cannot be that value."
.     endif
.   endif
.   ifthen (PASSCHCK eq 1)  |Passed all the checks!
.     if(OURKEY# eq 1) KEY$1 = KEY$V
.     if(OURKEY# eq 2) KEY$2 = KEY$V
.     if(OURKEY# eq 3) KEY$3 = KEY$V
.     if(OURKEY# eq 4) KEY$4 = KEY$V
.   elseif (PASSCHCK eq 0)
c     it proved that something was bad!
.     if(OURKEY# eq 1) focus item NEWKEY1E
.     if(OURKEY# eq 2) focus item NEWKEY2E
.     if(OURKEY# eq 3) focus item NEWKEY3E
.     if(OURKEY# eq 4) focus item NEWKEY4E
.     exit subprocedure  |IMPORTANT otherwise you might get a PASSCHCK = 1 on the LAST KEY VALUE!  BIG BIG OOPS.
.   endif
. end for
end subprocedure
|
subprocedure GETRECINFO
<comment> write 'sub: GETRECINFO'
c MOST IMPORTANT  All static information for record type.
. ifthen (abs(srst(gettxt(FORMS),' ')) gt 0)    | 3.
.   REC_#  = recnum(trimlr(sbst(gettxt(FORMS),1,abs(srst(gettxt(FORMS),' ')))))
. else
.   REC_#  = recnum(trimlr(gettxt(FORMS)))
. endif
|Right here, there could be a problem. If the form listed in FORMS had a different name than the record type
|name, REC# will be missing.
. KEY#C  = nkeys(REC_#) + dbtype(0)
. KEY1_REF = 0   |Initial state is to NOT REFRESH
. KEY2_REF = 0
. KEY3_REF = 0
. KEY4_REF = 0
. set KEY#1T KEY#2T KEY#3T KEY#4T KEY#5T KEY#6T KEY#7T KEY#8T (nmissing)
. for OURKEY# = 0 , KEY#C - dbtype(0)   | 1 is the CASEID
.   KEY$N   = keyname(REC_#, (OURKEY#+1))
c not needed here .   LAB_CNT = nvallab(REC_#, KEY$N)
.   ifthen ( OURKEY#  eq 0)
.     c CASEID do nothing
.   elseif ( OURKEY#  eq 1)
.     KEY#1T = vtype(REC_#,KEY$N)
.     D_ITEM_# = 9
.     KEY1_REF = 1
.     set item KEY1L, pack(varlabsc(REC_#, KEY$N))
.     show item KEY1
.   elseif ( OURKEY#  eq 2)
.     KEY#2T = vtype(REC_#,KEY$N)
.     D_ITEM_# = 11
.     KEY2_REF = 1
.     set item KEY2L, pack(varlabsc(REC_#, KEY$N))
.     show item KEY2
.   elseif ( OURKEY#  eq 3)
.     KEY#3T = vtype(REC_#,KEY$N)
.     D_ITEM_# = 13
.     KEY3_REF = 1
.     set item KEY3L, pack(varlabsc(REC_#, KEY$N))
.     show item KEY3
.   elseif ( OURKEY#  eq 4)
.     KEY#4T = vtype(REC_#,KEY$N)
.     D_ITEM_# = 15
.     KEY4_REF = 1
.     set item KEY4L, pack(varlabsc(REC_#, KEY$N))
.     show item KEY4
.   else
.     display infobox "Contact Administrator and add 5th Key Window"
.   endif
. end for
end subprocedure GETRECINFO
|
subprocedure GET_USER_CLICK
<comment> write 'sub: GET_USER_CLICK: '  CLCK_#
<comment> write '       - HIDEALL'
<comment> write '       - GETRECINFO'
<comment> write '       - REMOVAL'
<comment> write '       - CALL NAVIGATE SUBJINFO'
<comment> write '       - GOTO_SCREEN'
<comment> write '       - LOAD_VALUE'
<comment> write '       - MAKE_VIA_PART'
<comment> write '       - LOAD_SUBJ_INFO'
<comment> write '       - GET_KEYS'
| We already know from the intial value of KEY(#)_REF WHERE OR NOT A KEY SHOULD BE REFRESHED.  Know we modify refreshers depending on where user clicked
.   KEY1_CLK = 1  | Default is Refresh after every click
.   KEY2_CLK = 1
.   KEY3_CLK = 1
.   KEY4_CLK = 1
.   ifthen (CLCK_# eq -1) | Forms everything gets refreshed
.     execute subprocedure HIDEALL  | Could be a change of KEY
.     execute subprocedure GETRECINFO  |MOST IMPORTANT.  It gets all static information for record type.
.   elseif (CLCK_# eq 0)  | Case Only Refreshing Items get refreshed
.     execute subprocedure REMOVEALL  | just remove the previous key information
.     execute subprocedure GET_CASE_ID
.     set item BIG_SUBJ, CASE_$V
c.     POS0 = getpos(SUBJECTS)                     | ...remember the subject's position in the list and...
.     ifthen (meminfo('NAVIGATE.SUBJINFO:O',1) eq MEM_O)
.       execute subroutine NAVIGATE.SUBJINFO (SUBJINFO CASE_$V) DYNAMIC
.     endif
.   elseif (CLCK_# eq 1)  | Key 1
.     KEY1_CLK = 0       | Don't refresh KEY1 because key1 was clicked
.   elseif (CLCK_# eq 2)  | Key 2
.     KEY1_CLK = 0
.     KEY2_CLK = 0
.   elseif (CLCK_# eq 3)  | Key 3
.     KEY1_CLK = 0
.     KEY2_CLK = 0
.     KEY3_CLK = 0
.   elseif (CLCK_# eq 4)  | Key 4
.     KEY1_CLK = 0
.     KEY2_CLK = 0
.     KEY3_CLK = 0
.     KEY4_CLK = 0
.   else
.     display infobox "contact admin with error code CLCK_#=?"
.   endif
|
.   ifthen (M_ARG2 eq YES)  |double click go to form unless there is no form.
.     ifthen (getfocus(0) eq FORMS or KEY1 or KEY2 or KEY3 or KEY4)  |Only if they click forms or keys on a double click)
.       ifthen (gettxt(KEY1) eq 'No data')
.         display infobox 'Please click on NEW FORM'
.       elseif (nkeys(REC_#) eq CLCK_# )
.         execute subprocedure GOTO_SCREEN
.         exit subprocedure
.       elseif (KEY#C lt 1 + dbtype(0)) | No keys
.         ifthen (numbr(gettxt(REC_CNTL)) eq 1)
.           execute subprocedure GOTO_SCREEN
.         else
.           display yncbox  "Create a new form for subject " + CASE_$V + "?", response RESVAR | 1.
.           ifthen (RESVAR eq 1)
.             execute subprocedure GOTO_SCREEN
.           endif
.         endif
.       else
.         display infobox "Double click on last key to go to a form or press NEW FORM"
.       endif
.     endif
.   endif
|
.   if (nkeys(REC_#)  eq 0) execute subprocedure LOAD_VALUE   |Why is this here.  Do you need this?
.   VIA_$    = ' '
.   ifthen (KEY1_REF eq 1 and KEY1_CLK eq 1)  |Refresh Key 1
.     remove all KEY1
.     OURKEY#  = 1
.     D_ITEM_# = KEY1
.     VIA_$    = ' '
.     execute subprocedure LOAD_VALUE
.     ifthen (gettxt(KEY1) eq 'No data')
.       KEY1_CLK = 0
.       KEY2_CLK = 0
.       KEY3_CLK = 0
.       KEY4_CLK = 0
.     endif
.   endif
.   ifthen (KEY2_REF eq 1 and KEY2_CLK eq 1)  |Refresh Key 2
.     execute subprocedure REFRESH_KEY2
.   endif
.   ifthen (KEY3_REF eq 1 and KEY3_CLK eq 1)  |Refresh Key 3
.     execute subprocedure REFRESH_KEY3
.   endif
.   ifthen (KEY4_REF eq 1 and KEY4_CLK eq 1)  |Refresh Key 4
.     execute subprocedure REFRESH_KEY4
.   endif
. execute subprocedure LOAD_SUBJ_INFO  |Look for anthing that the DBA wanted made special
. ifthen (gettxt(KEY1) ne 'No data')
.   execute subprocedure GET_KEYS  | At the end of the day get the information that is display for the keys
. endif
end subprocedure GET_USER_CLICK
|
subprocedure GET_KEYS
<comment> write 'sub: GET_KEYS, VIA: ' VIA_$
c used for passing key information to DATA ENTRY SCREENS
. set KEY$1 KEY$2 KEY$3 KEY$4 (missing)
. for OURKEY# = 0 , KEY#C - dbtype(0)   | 1 is the CASEID
.   KEY$N   = keyname(REC_#, (OURKEY#+1))
.   VTYPE_#  = vtype(REC_#, KEY$N)
.   if(OURKEY# eq 1) KEY$V= trim(gettxt(KEY1)); D_ITEM_# = KEY1
.   if(OURKEY# eq 2) KEY$V= trim(gettxt(KEY2)); D_ITEM_# = KEY2
.   if(OURKEY# eq 3) KEY$V= trim(gettxt(KEY3)); D_ITEM_# = KEY3
.   if(OURKEY# eq 4) KEY$V= trim(gettxt(KEY4)); D_ITEM_# = KEY4
.   POS = abs(srst(KEY$V, ' ')) - 1  | A space indicates that value labels were added
.   if (POS < 0) POS = len(KEY$V)
.   KEY$V = sbst(KEY$V, 1, POS)
c   1 categorical variable must have the number passed to the data entry screen, not the character!
.   ifthen (VTYPE_# eq 2)  | Categorical
.     for EACH_CAT = 1,nvalid(REC_#,KEY$N)  |must cycle thru and get values instead of use "catint"
.       if (svval(REC_#,KEY$N, EACH_CAT ) eq  KEY$V ) WRITE //// EACH_CAT; exit for
.     end for
.     compute KEY$V = format(EACH_CAT)
.   endif
.   if(OURKEY# eq 1) KEY$1 = KEY$V
.   if(OURKEY# eq 2) KEY$2 = KEY$V
.   if(OURKEY# eq 3) KEY$3 = KEY$V
.   if(OURKEY# eq 4) KEY$4 = KEY$V
. end for
<comment> WRITE 'GET_KEYS:  ' CASE_$V 15t KEY$1 30t KEY$2 45t KEY$3 60t KEY$4
end subprocedure
|
subprocedure MAKE_VIA_PART
<comment> write 'sub: MAKE_VIA_PART'
c this is very trick due to the nature of KEYNAME.  Be VERY careful when you mess with this.
.   KEY$N   = keyname(REC_#, (VIAKEY#+1))
.   VTYPE_#  = vtype(REC_#, KEY$N)
.   if(VIAKEY# eq 0) |NO need to construct via
.   if(VIAKEY# eq 1) KEY$V= trim(gettxt(KEY1)); D_ITEM_# = KEY1
.   if(VIAKEY# eq 2) KEY$V= trim(gettxt(KEY2)); D_ITEM_# = KEY2
.   if(VIAKEY# eq 3) KEY$V= trim(gettxt(KEY3)); D_ITEM_# = KEY3
.   ifthen (VTYPE_# eq 1)  | String
.   POS = abs(srst(KEY$V, ' '))-1  | this assumes that there are value labels associated
.   if (POS < 0) POS = len(KEY$V)  | with this string...what if it is a string with a space?
.     KEY$V = sbst(KEY$V, 1, POS)
.     KEY$V  = '"' + KEY$V + '"'
.   elseif (VTYPE_# = 2)  | Categorical
.     write KEY$N "This is a categorical "
.   elseif (VTYPE_# eq 3)  | Date
.     DATE#V = cdate(KEY$V, datemap(REC_#, KEY$N))
.     KEY$V  = format(DATE#V)
.   elseif (VTYPE_# eq 4)  | Time
.     TIME#V = ctime(KEY$V, timemap(REC_#, KEY$N))
.     KEY$V  = format(TIME#V)
.   endif
.   POS = abs(srst(KEY$V, ' '))-1  | A space indicates that value labels were added
.   if (POS < 0) POS = len(KEY$V)  | Note due to the -1 when creating POS the number
.   KEY$V = sbst(KEY$V, 1, POS)
end subprocedure MAKE_VIA_PART
|
subprocedure MAKE_TEMP_KEYS
. TEMPKEY1 = KEY$1
. TEMPKEY2 = KEY$2
. TEMPKEY3 = KEY$3
. TEMPKEY4 = KEY$4
end subprocedure MAKE_TEMP_KEYS
|
subprocedure REFRESH_KEY2
.     remove all KEY2
.     OURKEY#  = 2
.     VIAKEY#  = 1
.     VIA_$    = ''  | VIA_$ gets reset
.     execute subprocedure MAKE_VIA_PART
.     VIA_$    = 'via (' + KEY$V +')'
c special note: this is in a VERY SPEFICI ORDER.  1st MAKE_VIA_PART 2nd D_ITEM_#=
.     D_ITEM_# = KEY2
.     execute subprocedure LOAD_VALUE
end subprocedure
|
subprocedure REFRESH_KEY3
.     remove all KEY3
.     VIAKEY#  = 1
.     execute subprocedure MAKE_VIA_PART
.     VIA_$    = 'via (' + KEY$V
.     VIAKEY#  = 2
.     execute subprocedure MAKE_VIA_PART
.     VIA_$    = VIA_$ + ' ' + KEY$V +')'
.     OURKEY#  = 3
.     D_ITEM_# = KEY3
.     execute subprocedure LOAD_VALUE
end subprocedure REFRESH_KEY3
|
subprocedure REFRESH_KEY4
.     remove all KEY4
|     start making via
.     VIAKEY#  = 1
.     execute subprocedure MAKE_VIA_PART
.     VIA_$    = 'via (' + KEY$V
.     VIAKEY#  = 2
.     execute subprocedure MAKE_VIA_PART
.     VIA_$    = VIA_$ + ' ' + KEY$V
.     VIAKEY#  = 3
.     execute subprocedure MAKE_VIA_PART
.     VIA_$    = VIA_$ + ' ' + KEY$V +')'
|     end making via
.     OURKEY#  = 4
.     D_ITEM_# = KEY4
.     execute subprocedure LOAD_VALUE
end subprocedure REFRESH_KEY4
|
subprocedure FIND_SUBJECT | (CASE_$V)
<comment> write 'sub: FIND_SUBJECT'
. integer * 1 FIND#
. FOUNDID = NO
. ifthen (meminfo('NAVIGATE.FIND_SUBJ:O',1) eq MEM_O) | custom find
.   execute subroutine NAVIGATE.FIND_SUBJ returning (FIND#) DYNAMIC
.   ifthen (FIND# eq 2)
.     for x = 1, ARRAYSZ#
.       ifthen (COMMON1(x) eq trimlr(upper(CASE_$V)))| If the passed in PTID equals the PTID in the list
.         FOUNDID = YES
.         exit for
.       endif
.     end for
.   elseif (FIND# eq 3)
.     for x = 1, ARRAYSZ#
.       ifthen (COMMON2(x) eq trimlr(upper(CASE_$V)))| If the passed in PTID equals the PTID in the list
.         FOUNDID = YES
.         exit for
.       endif
.     end for
.   endif
. else
.   for EACH_ID = 1, ARRAYSZ#
c . write 'In FIND_SUBJ with ' [CASE_A(x)]FOUNDID CASE_$V
.     ifthen (trim(CASE_A( EACH_ID ) ) eq trimlr(upper(CASE_$V)))| If the passed in PTID equals the PTID in the list
.      FOUNDID = YES
.      exit for
.    endif
.   end for
. endif
. ifthen (FOUNDID eq YES)
.   select item SUBJECTS, EACH_ID
.   set item BIG_SUBJ, CASE_A(getpos(SUBJECTS))
.   ifthen (meminfo('NAVIGATE.SUBJINFO:O',1) eq MEM_O)
.   EACH_ID = getpos(SUBJECTS)
.   CASE_$V = CASE_A(EACH_ID)
.     execute subroutine NAVIGATE.SUBJINFO (SUBJINFO CASE_$V) DYNAMIC
.   endif
. end if
end subprocedure FIND_SUBJECT
|
subprocedure LOADSUBJECTS
<comment> write 'sub: LOADSUBJECTS'
. integer * 1 SHOW1 SHOW2 SHOW3
. SHOW1 = YES
. set SHOW2 SHOW3 (0)
. ifthen (meminfo('NAVIGATE.LOADSUBJ:O',1) eq MEM_O)
.   execute subroutine NAVIGATE.LOADSUBJ (SUBJECTS) returning (SHOW1 SHOW2 SHOW3) DYNAMIC
. endif
. ifthen (SHOW1 eq YES or SHOW2 eq YES or SHOW3 eq YES)
.   remove all SUBJECTS
.   execute subprocedure MAKE_CASE_LIST
.   SHOW_$ = ''
.   for x = 1, ARRAYSZ#
.     ifthen (SHOW1 eq YES)
.       SHOW_$ = CASE_A(x)
.     endif
.     ifthen (SHOW2 eq YES and exists(COMMON1(x)) eq YES and len(COMMON1(x)) gt 0)
.       SHOW_$ = SHOW_$ + ' ' + COMMON1(x)
.     else
.       SHOW_$ = SHOW_$ + '     '
.     endif
.     ifthen (SHOW3 eq YES and exists(COMMON2(x)) eq YES)
.       SHOW_$ = SHOW_$ + ' ' + COMMON2(x)
.     endif
.     append item SUBJECTS, trimlr(SHOW_$)
.     SHOW_$ = ''
.   end for
.   select item SUBJECTS, getnitem(SUBJECTS)
. endif
end subprocedure LOADSUBJECTS
|
subprocedure MAKE_CASE_LIST
<comment> write 'sub: MAKE_CASE_LIST'
. redefine array 'CASE_A'  (ARRAYSZ#)
. redefine array 'COMMON1' (ARRAYSZ#)
. redefine array 'COMMON2' (ARRAYSZ#)
. CASE# = 0
. process cases
.   CASE# = CASE# + 1
.   CASE_A(CASE#) = varget(CASE_$N)     | Value of the case (the first common variable)
.   ifthen (nvarsc(0) > 1)
.     COMMON1(CASE#) = varget( varname( 0, 2 ) )  | Value of the second common variable
.   endif
.   ifthen (nvarsc(0) > 2)
.     COMMON2(CASE#) = varget( varname( 0, 3 ) )  | Value of the third common variable
.   endif
. end cases
end subprocedure MAKE_CASE_LIST
|
subprocedure CREATE_NEW_CASE
c IT PASSED THE TEST NOW CREATE IT create buffer to insert new case
. ARRAYSZ# = ARRAYSZ# + 1
. ifthen (meminfo('NAVIGATE.NEWCASE:O',1) eq MEM_O)
.   execute subroutine NAVIGATE.NEWCASE returning (CASE_$V) DYNAMIC
. endif
. EXECUTE SUBPROCEDURE NEW_CASE_ID
| NEW CASE HAS BEEN CREATED.  NOW FIND IT AND FOCUS ON IT
. ifthen (meminfo('NAVIGATE.LOADSUBJECTS:O',1) eq MEM_O)
.   execute subroutine NAVIGATE.LOADSUBJECTS (SUBJECTS) DYNAMIC
. else
.   execute subprocedure LOADSUBJECTS
. endif
.   execute subprocedure FIND_SUBJECT | (CASE_$V)
.   ifthen (FOUNDID eq YES)
.     CLCK_# = 0
.     execute subprocedure GET_USER_CLICK
.     focus item FORMS
.    endif
end subprocedure
|
subprocedure GET_CASE_ID
. CASE_$V = trim( CASE_A( getpos( SUBJECTS ) ) )
. CASE_#V = numbr( CASE_$V )
c . CASE_$V = upper(trimlr(gettxt(FIND_SUB)))  | old way of doing this
end subprocedure
|
|
subprocedure ADD_CASE_ID_TO_BUFFER_LINE
. ifthen (VTYPE(0,CASE_$N) eq 1 )  | string caseid
.   ifthen ( sbst(CASE_$V,1,1) <> "'")  | is it in qoutes
.     BUFF$ = BUFF$ + '"' + CASE_$V + '"' | add qoutes
.   else
.     BUFF$ = BUFF$ + CASE_$V
.   endif
. endif
end subprocedure
|
|
subprocedure CREATE_BUFFER
. LINE# = 1
. delete buffer BUFF$N
. create buffer BUFF$N
end subprocedure
|
|
subprocedure WRITE_TO_BUFFER
. insert line into buffer BUFF$N numbered LINE# from BUFF$
. LINE# = LINE# + 1
end subprocedure
|
|
SUBPROCEDURE NEW_CASE_ID
CIF EQ 1, 0<CASE_TYPE>
. NEW CASE IS CASE_$V
CIF FALSE
. NEW CASE IS CASE_#V
CIF END
. END CASE IS
. ARRAYSZ# = numcases(0)
END SUBPROCEDURE
|
|
|
do repeat RECX = <GREC1>
                 <GREC2>
                 <GREC3>
                 <GREC4>
. SUBPROCEDURE get_rec_!RECX
CIF EQ 1, 0<CASE_TYPE>
.   OLD CASE IS CASE_$V
CIF FALSE
.   OLD CASE IS CASE_#V
CIF END
.     db_row = 0
.     PROCESS REC RECX
.       execute subprocedure MAKE_ROW_OF_ALL_KEYS
.     END REC
.   END CASE IS
. END SUBPROCEDURE
end repeat
|
|
subprocedure MAKE_ROW_OF_ALL_KEYS
C WRITE '-----------   Make ROW ADB Array     -----------'
. db_row = db_row + 1
. for each_key = 1 + dbtype(0), KEY#C
.   db_rec_keys (db_row, each_key) = varget( keyname( REC_#, each_key ) )
. end for
end subprocedure
|
|
subprocedure SET_KEY_REFRESH_START
. key_refresh_start = start_key + dbtype(0) | note CASEID is first key
end subprocedure
|
|
subprocedure view_all_keys
WRITE '---------   ALL  VALUES in Array   --------'
. txt = ""
. for each_db_row = 1, db_row
. txt = format (each_db_row ) + ': '
.   for each_key = 1 + dbtype(0), KEY#C
.     txt = txt + db_rec_keys (each_db_row, each_key)
.     if(each_key lt KEY#C) txt = txt + " | "
.   end for
.   write txt
. end for
end subprocedure
|
|
subprocedure CREATE_MATCHED_KEY_ARRAYS
WRITE '--------   Create Match Key Arrays --------'
. first_match = 0 | no matching row yet
. set rec_key_list_pointer * (1)  | starting position for each key list
. set rec_key_list * (missing)
. for each_db_row = 1, db_row
|   check each row to see if it matches the criteria.  If yes, grab all key values
.   if ( first_match eq 0 ) execute subprocedure CHECK_ALL_MATCH_CRITERIA
.   for each_key = 1 + dbtype(0), KEY#C
.     current_key_value = db_rec_keys (each_db_row, each_key)
.     execute subprocedure PREVIOUS_KEYS_MATCH
.     ifthen  ( previous_keys_match = 0 )
.       exit for | all key values before this value must match
.     endif
.     execute subprocedure is_key_value_unique    | if unique add to list
.   end for
. end for
end subprocedure
|
|
subprocedure CHECK_ALL_MATCH_CRITERIA
write '------ Looking for First Match   ----------'
. if(first_match eq 1) exit subprocedure | values already set
. ifthen (key_refresh_start eq 1 + dbtype(0) ) | special rule for first keys- grab first row
.   first_match = 1
. else | if all keys upto match key match set flag
write 'checking for matches. Key1: ' match_value( 1 ) match_value( 2 ) match_value( 3 )
.   for match_key = 1 + dbtype(0), key_refresh_start - 1
write 'key' match_key 'DB:'  db_rec_keys (each_db_row, match_key)  ' value: ' match_value( match_key )
.     ifthen(  match_value( match_key - dbtype(0) ) = db_rec_keys (each_db_row, match_key) )
.       first_match = 1
.     else
.       first_match = 0
.       exit subprocedure
.     endif
.   end for
. endif
. ifthen (first_match eq 1) | set all of the match values.
write 'settting match criteria: '
.   for match_key = 1 + dbtype(0), KEY#C
write 'key ' match_key ' value ' db_rec_keys (each_db_row, match_key)
.       match_value( match_key ) = db_rec_keys (each_db_row, match_key)
.   end for
. endif
end subprocedure
|
|
subprocedure previous_keys_match
c write '-----------   previous_keys_match   ---------------'
. ifthen (each_key eq 1 + dbtype(0) ) | special rule for first keys
.   previous_keys_match = 1
.   exit subprocedure
. endif
. previous_keys_match = 0
. for check_key = 1 + dbtype(0), each_key - 1  | Check all keys up to but not including current key
| write 'checking key: ' check_key '.  db value: ' db_rec_keys (each_db_row, check_key ) ' and match value: ' match_value (check_key)
.   ifthen ( db_rec_keys (each_db_row, check_key ) eq match_value (check_key) )
.     previous_keys_match = 1
.   else
write 5t 'failed match. DB: ' db_rec_keys (each_db_row, check_key ) ' != Match: ' match_value (check_key)
.     previous_keys_match = 0
.     exit subprocedure | can exit immediately when a single match fails
.  endif
. end for
end subprocedure
|
|
subprocedure is_key_value_unique
. for each_element = 1, rec_key_list_pointer(each_key)
.   ifthen ( rec_key_list ( each_element, each_key ) eq current_key_value )
.     exit subprocedure | value is already in list move on.
.   endif
. end for
. rec_key_list (rec_key_list_pointer(each_key), each_key ) = current_key_value
. rec_key_list_pointer(each_key) = rec_key_list_pointer(each_key) + 1
end subprocedure
|
|
subprocedure refresh_keys
| here cycle through keys, start with first that needs to be updated. append list
WRITE // '-----------   show values to update -----------'
ifthen (db_row eq 0 )
. write "No data"
. exit subprocedure
endif
c WRITE 'These keys: ' key_refresh_start  ' - ' KEY#C
. for each_key = key_refresh_start , KEY#C
write 'key ' each_key ' ( ' [rec_key_list_pointer(each_key) - 1 ] ' values to update: '
.   for each_row = 1, rec_key_list_pointer(each_key) - 1
.       key_name = keyname( REC_#, each_key )
.       key_value = rec_key_list( each_row, each_key )
.       key_vtype = vtype( REC_#, key_name )
.       ifthen ( key_vtype eq 1 or 3 or 4)
.         key_value_label = trim( fst( vallabsc ( REC_#, key_name, key_value), "" ) )
.       else
.         key_value_label = trim( fst( vallabsc ( REC_#, key_name, numbr( key_value ) ) , "" ) )
.       endif
.       DISPLAY_TEXT = key_value + " : " + key_value_label
write 5t DISPLAY_TEXT
c .       write 5t '  row: ' each_row
                 ' value: ' key_value
                 ' label: ' key_value_label
.   end for
. end for
end subprocedure
|
|
subprocedure SET_MATCH_VALUES
. set match_value * (missing)
. if (gettxt(KEY1) EQ 'No data' ) exit subprocedure | No data
. if (exists(gettxt(KEY1)) EQ 0 ) exit subprocedure | No text appended to KEY1
. execute subprocedure GET_KEYS
. ifthen( getfocus(0) eq KEY1 )
.  match_value (1) = KEY$1
. elseif( getfocus(0) eq KEY2 )
.   match_value (1) = KEY$1
.   match_value (2) = KEY$2
. elseif( getfocus(0) eq KEY3 )
.   match_value (1) = KEY$1
.   match_value (2) = KEY$2
.   match_value (2) = KEY$3
. endif
write // 'match values: ' match_value (1) match_value (2) match_value (3)  //

end subprocedure
|
|
end retrieval
|}
